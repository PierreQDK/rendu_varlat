# 📚 Librairies
library(data.table)
library(ggplot2)
library(corrplot)
library(pls)
library(caret)
library(gridExtra)
library(FactoMineR)
library(factoextra)
library(data.table)
library(ggplot2)
library(gridExtra)
library(corrplot)

# 📥 Lecture des données
upenn <- fread("UPENN.txt")
gt <- fread("GT.txt")

# ✅ Création de la variable cible : charge énergétique totale
upenn$EnergyLoad <- upenn$HeatTotal + upenn$CoolTotal
gt$EnergyLoad <- gt$HeatTotal + gt$CoolTotal

# ✅ Suppression de colonnes inutiles (ID, HeatTotal, CoolTotal)
Xupenn <- upenn[, !c("ID", "HeatTotal", "CoolTotal")]
Xgt <- gt[, !c("ID", "HeatTotal", "CoolTotal")]

# 🔍 Vérification structure
str(Xupenn)
summary(Xupenn$EnergyLoad)

# 📊 Histogramme de la variable cible
ggplot(Xupenn, aes(x = EnergyLoad)) +
  geom_histogram(bins = 30, fill = "steelblue", color = "white") +
  labs(title = "Distribution de la charge énergétique - UPENN")


---------------------------
  
# Quetsion 1 
  
upenn$sqrt_EnergyLoad <- sqrt(upenn$EnergyLoad)
upenn$sqrt_EnergyLoad <- sqrt(upenn$EnergyLoad)


# 🔍 4. Visualisation de la distribution des valeurs de Y (originale et transformée)
p1 <- ggplot(upenn, aes(x = EnergyLoad)) +
  geom_histogram(bins = 30, fill = "steelblue", color = "white") +
  labs(title = "Distribution de Y (EnergyLoad)", x = "EnergyLoad", y = "Count")

p2 <- ggplot(upenn, aes(x = sqrt_EnergyLoad)) +
  geom_histogram(bins = 30, fill = "darkgreen", color = "white") +
  labs(title = "Distribution de √Y", x = "√EnergyLoad", y = "Count")

grid.arrange(p1, p2, ncol = 2)


# 🧼 6. Préparation des matrices pour modélisation
# On retire les variables inutiles (ID, HeatTotal, CoolTotal)
Xtrain <- upenn[, !c("ID", "HeatTotal", "CoolTotal", "EnergyLoad")]
Xtest <- gt[, !c("ID", "HeatTotal", "CoolTotal", "EnergyLoad")]

# Structure des jeux
str(Xtrain)
str(Xtest)



# ────────────────────────────────────────
# 📘 QUESTION 2 : PCR - modèle + RMSEP
# ────────────────────────────────────────

library(pls)

# 📌 1. Formule
formule <- sqrt_EnergyLoad ~ .

# ⚙️ 2. Modèle PCR avec CV
model_pcr <- pcr(
  formule,
  data = Xtrain,
  scale = TRUE,
  validation = "CV"
)

# 📊 3. Courbe RMSEP (APP + CV)
validationplot(model_pcr, val.type = "RMSEP", type = "b", legendpos = "topright")
title("Validation croisée - RMSEP (PCR)")

# 🧮 4. Récupérer les erreurs (APP et CV)
rmsep_obj <- RMSEP(model_pcr, estimate = c("train", "CV"))
# 3D array : [train vs CV, comp, response]
rmsep_app <- rmsep_obj$val[1, , 1]
rmsep_cv  <- rmsep_obj$val[2, , 1]

# 📝 5. Créer le tableau récap
table_rmsep <- data.frame(
  Composante = 0:(length(rmsep_app) - 1),
  RMSEP_APP = round(rmsep_app, 4),
  RMSEP_CV  = round(rmsep_cv, 4)
)
print(table_rmsep)

# 🏆 6. Choix du nb optimal de composantes selon RMSEP CV
nb_opt_pcr <- which.min(rmsep_cv) - 1
cat("✅ Nombre optimal de composantes (CV) :", nb_opt_pcr, "\n")

# 📤 7. Prédiction sur le jeu test
Y_test_obs <- Xtest$sqrt_EnergyLoad
Y_test_pred <- predict(model_pcr, newdata = Xtest, ncomp = nb_opt_pcr)

# 📉 8. RMSEP test
rmsep_test <- sqrt(mean((Y_test_obs - Y_test_pred)^2))
cat("📊 RMSEP sur le jeu test :", round(rmsep_test, 4), "\n")

# 📈 9. Graphe Y obs vs Y préd (test)
plot(Y_test_obs, Y_test_pred,
     xlab = "Y observé (test)", ylab = "Y prédit (test)",
     main = paste("PCR : test avec", nb_opt_pcr, "composantes"),
     pch = 19, col = "darkblue")
abline(a = 0, b = 1, col = "red")







