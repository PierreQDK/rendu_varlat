# ğŸ“š Librairies
library(data.table)
library(ggplot2)
library(corrplot)
library(pls)
library(caret)
library(gridExtra)
library(FactoMineR)
library(factoextra)
library(data.table)
library(ggplot2)
library(gridExtra)
library(corrplot)

# ğŸ“¥ Lecture des donnÃ©es
upenn <- fread("UPENN.txt")
gt <- fread("GT.txt")

# âœ… CrÃ©ation de la variable cible : charge Ã©nergÃ©tique totale
upenn$EnergyLoad <- upenn$HeatTotal + upenn$CoolTotal
gt$EnergyLoad <- gt$HeatTotal + gt$CoolTotal

# âœ… Suppression de colonnes inutiles (ID, HeatTotal, CoolTotal)
Xupenn <- upenn[, !c("ID", "HeatTotal", "CoolTotal")]
Xgt <- gt[, !c("ID", "HeatTotal", "CoolTotal")]

# ğŸ” VÃ©rification structure
str(Xupenn)
summary(Xupenn$EnergyLoad)

# ğŸ“Š Histogramme de la variable cible
ggplot(Xupenn, aes(x = EnergyLoad)) +
  geom_histogram(bins = 30, fill = "steelblue", color = "white") +
  labs(title = "Distribution de la charge Ã©nergÃ©tique - UPENN")


---------------------------
  
# Quetsion 1 
  
upenn$sqrt_EnergyLoad <- sqrt(upenn$EnergyLoad)
upenn$sqrt_EnergyLoad <- sqrt(upenn$EnergyLoad)


# ğŸ” 4. Visualisation de la distribution des valeurs de Y (originale et transformÃ©e)
p1 <- ggplot(upenn, aes(x = EnergyLoad)) +
  geom_histogram(bins = 30, fill = "steelblue", color = "white") +
  labs(title = "Distribution de Y (EnergyLoad)", x = "EnergyLoad", y = "Count")

p2 <- ggplot(upenn, aes(x = sqrt_EnergyLoad)) +
  geom_histogram(bins = 30, fill = "darkgreen", color = "white") +
  labs(title = "Distribution de âˆšY", x = "âˆšEnergyLoad", y = "Count")

grid.arrange(p1, p2, ncol = 2)


# ğŸ§¼ 6. PrÃ©paration des matrices pour modÃ©lisation
# On retire les variables inutiles (ID, HeatTotal, CoolTotal)
Xtrain <- upenn[, !c("ID", "HeatTotal", "CoolTotal", "EnergyLoad")]
Xtest <- gt[, !c("ID", "HeatTotal", "CoolTotal", "EnergyLoad")]

# Structure des jeux
str(Xtrain)
str(Xtest)



# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ“˜ QUESTION 2 : PCR - modÃ¨le + RMSEP
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

library(pls)

# ğŸ“Œ 1. Formule
formule <- sqrt_EnergyLoad ~ .

# âš™ï¸ 2. ModÃ¨le PCR avec CV
model_pcr <- pcr(
  formule,
  data = Xtrain,
  scale = TRUE,
  validation = "CV"
)

# ğŸ“Š 3. Courbe RMSEP (APP + CV)
validationplot(model_pcr, val.type = "RMSEP", type = "b", legendpos = "topright")
title("Validation croisÃ©e - RMSEP (PCR)")

# ğŸ§® 4. RÃ©cupÃ©rer les erreurs (APP et CV)
rmsep_obj <- RMSEP(model_pcr, estimate = c("train", "CV"))
# 3D array : [train vs CV, comp, response]
rmsep_app <- rmsep_obj$val[1, , 1]
rmsep_cv  <- rmsep_obj$val[2, , 1]

# ğŸ“ 5. CrÃ©er le tableau rÃ©cap
table_rmsep <- data.frame(
  Composante = 0:(length(rmsep_app) - 1),
  RMSEP_APP = round(rmsep_app, 4),
  RMSEP_CV  = round(rmsep_cv, 4)
)
print(table_rmsep)

# ğŸ† 6. Choix du nb optimal de composantes selon RMSEP CV
nb_opt_pcr <- which.min(rmsep_cv) - 1
cat("âœ… Nombre optimal de composantes (CV) :", nb_opt_pcr, "\n")

# ğŸ“¤ 7. PrÃ©diction sur le jeu test
Y_test_obs <- Xtest$sqrt_EnergyLoad
Y_test_pred <- predict(model_pcr, newdata = Xtest, ncomp = nb_opt_pcr)

# ğŸ“‰ 8. RMSEP test
rmsep_test <- sqrt(mean((Y_test_obs - Y_test_pred)^2))
cat("ğŸ“Š RMSEP sur le jeu test :", round(rmsep_test, 4), "\n")

# ğŸ“ˆ 9. Graphe Y obs vs Y prÃ©d (test)
plot(Y_test_obs, Y_test_pred,
     xlab = "Y observÃ© (test)", ylab = "Y prÃ©dit (test)",
     main = paste("PCR : test avec", nb_opt_pcr, "composantes"),
     pch = 19, col = "darkblue")
abline(a = 0, b = 1, col = "red")







